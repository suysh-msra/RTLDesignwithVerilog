# RTLDesignwithVerilog

# Contents
[2. DAY 1 - Introduction to Verilog RTL Design and Synthesis](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#2-day-1---introduction-to-verilog-rtl-design-and-synthesis) <br>
* [2.1 SKY130RTL D1SK1 - Introduction to open-source simulator iverilog](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#21-sky130rtl-d1sk1---introduction-to-open-source-simulator-iverilog) <br>
  - [2.1.1 SKY130RTL D1SK1 L1 Introduction iverilog design and test bench](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#211-sky130rtl-d1sk1-l1-introduction-iverilog-design-and-test-bench) <br>
* [2.2 SKY130RTL D1SK2 - Labs using iverilog  and gtkwave](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#22-sky130rtl-d1sk2---labs-using-iverilog--and-gtkwave) <br>
  - [2.2.1 SKY130RTL D1SK2 L1 Lab 1 Introduction to Lab](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#221-sky130rtl-d1sk2-l1-lab-1-introduction-to-lab) <br>
  - [2.2.2 SKY130RTL D1SK2 L2 Lab 2 Introduction to iVerilog GTKWave part1](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#222-sky130rtl-d1sk2-l2-lab-2-introduction-to-iverilog-gtkwave-part1) <br>
  - [2.2.3 SKY130RTL D1SK2 L3 Lab 2 Introduction to iVerilog GTKWave part2](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#223-sky130rtl-d1sk2-l3-lab-2-introduction-to-iverilog-gtkwave-part2) <br>
* [2.3 SKY130RTL D1SK3 - Introduction to Yosys and Logic Synthesis](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#23-sky130rtl-d1sk3---introduction-to-yosys-and-logic-synthesis) <br>
  - [2.3.1 SKY130RTL D1SK3 L1 Introduction to Yosys](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#231-sky130rtl-d1sk3-l1-introduction-to-yosys) <br>
  - [2.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#232-sky130rtl-d1sk3-l2-introduction-to-logic-synthesis-part1) <br>
  - [2.3.3 SKY130RTL D1SK3 L3 Introduction to logic synthesis part2](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#233-sky130rtl-d1sk3-l3-introduction-to-logic-synthesis-part2) <br>
* [2.4 SKY130RTL D1SK4 - Labs Using Yosys and SKY130 PDKs](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#24-sky130rtl-d1sk4---labs-using-yosys-and-sky130-pdks) <br>
  - [2.4.1 SKY130RTL D1SK4 L1 lab3 Yosys 1 good mux](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#241-sky130rtl-d1sk4-l1-lab3-yosys-1-good-mux) <br>

[NOTE](https://github.com/Suysh-msra/RTLDesignwithVerilog#note)

[3. DAY 2 - Timing libs, hierarchical vs flat synthesis and efficient flop coding styles](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#3-day-2---timing-libs-hierarchical-vs-flat-synthesis-and-efficient-flop-coding-styles) <br>
* [3.1 SKY130RTL D2SK1 - Introduction to timing .libs](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#31-sky130rtl-d2sk1---introduction-to-timing-dot-libs) <br>
* [3.2 SKY130RTL D2SK2 - Hierarchical vs Flat Synthesis](https://github.com/Suysh-msra/RTLDesignwithVerilog#32-sky130rtl-d2sk2---hierarchical-vs-flat-synthesis) <br>
* [3.3 SKY130RTL D2SK3 - Various Flop Coding Styles and Optimization](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#33-sky130rtl-d2sk3---various-flop-coding-styles-and-optimization) <br>
  - [3.3.1 SKY130RTL D2SK3 L1 Why Flops and Flop coding styles](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#331-sky130rtl-d2sk3-l1-why-flops-and-flop-coding-styles) <br>
  - [3.3.2 SKY130RTL D2SK3 L3 lab Flop Synthesis Simulation](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#332-sky130rtl-d2sk3-l3-lab-flop-synthesis-simulation) <br>
  - [3.3.3 SKY130RTL D2SK3 L5 Interesting Optimisations](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#333-sky130rtl-d2sk3-l5-interesting-optimisations) <br>

[4. DAY 3 - Combinational and Sequential Optimizations](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#4-day-3---combinational-and-sequential-optimizations) <br>
* [4.1 SKY130RTL D3SK2 - Combinational Logic Optimizations](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#41-sky130rtl-d3sk2---combinational-logic-optimizations) <br>
* [4.2 SKY130RTL D3SK3 - Sequential Logic Optimizations](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#42-sky130rtl-d3sk3---sequential-logic-optimizations) <br>
* [4.3 SKY130RTL D3SK3 - Sequential Logic Optimizations for unused outputs](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#43-sky130rtl-d3sk3---sequential-logic-optimizations-for-unused-outputs) <br>

[5. DAY 4 - GLS, Blocking VS Non-blocking and Synthesis-Simulation mismatch](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#5-day-4---gls-blocking-vs-non-blocking-and-synthesis-simulation-mismatch) <br>
* [5.1 SKY130RTL D4SK1 - GLS, Synthesis-Simulation mismatch and Blocking/Non-blocking Statements](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#51-sky130rtl-d4sk1---gls-synthesis-simulation-mismatch-and-blockingnon-blocking-statements) <br>
  - [5.1.1 SKY130RTL D4SK1 L1 GLS Concepts and Flow Using iVerilog](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#511-sky130rtl-d4sk1-l1-gls-concepts-and-flow-using-iverilog) <br>
  - [5.1.2 SKY130RTL D4SK1 L2 Synthesis and Simulation Mismatch](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#512-sky130rtl-d4sk1-l2-synthesis-and-simulation-mismatch) <br>
  - [5.1.3 SKY130RTL D4SK1 L3 Blocking and Non-Blocking Statements in Verilog](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#513-sky130rtl-d4sk1-l3-blocking-and-non-blocking-statements-in-verilog) <br>
* [5.2 SKY130RTL D4SK2 - Labs on GLS and Synthesis-Simulation Mismatch](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#52-sky130rtl-d4sk2---labs-on-gls-and-synthesis-simulation-mismatch) <br>
* [5.3 SKY130RTL D4SK3 - Labs on Synthesis-Simulation mismatch for blocking statements](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#53-sky130rtl-d4sk3---labs-on-synthesis-simulation-mismatch-for-blocking-statements) <br>
  
  
[6. DAY 5 - If, case, for loop and for generate ](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#6-day-5---if-case-for-loop-and-for-generate) <br>
* [6.1 SKY130RTL D5SK1 - If Case constructs](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#61-sky130rtl-d5sk1---if-case-constructs) <br>
* [6.2 SKY130RTL D5SK2 - Labs on "Incomplete If Case"](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#62-sky130rtl-d5sk2---labs-on-incomplete-if-case) <br>
* [6.3 SKY130RTL D5SK3 - Labs on "Incomplete and Overlapping Case"](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#63-sky130rtl-d5sk3---labs-on-incomplete-and-overlapping-case) <br>
* [6.4 SKY130RTL D5SK4 - For Loop and For Generate](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#64-sky130rtl-d5sk4---for-loop-and-for-generate) <br>
* [6.5 SKY130RTL D5SK5 - Labs on "For loop" and "For Generate"](https://github.com/Suysh-msra/RTLDesignwithVerilog/blob/main/README.md#65-sky130rtl-d5sk5---labs-on-for-loop-and-for-generate) <br>

[Contributors](https://github.com/Suysh-msra/RTLDesignwithVerilog#contributors)<br>

[Acknowledgment](https://github.com/Suysh-msra/RTLDesignwithVerilog#acknowledgment)<br>

[Contact Information](https://github.com/Suysh-msra/RTLDesignwithVerilog#contact-information)<br>

# 1. An Introduction to the lecture series 

Following is a summary of a 5 day workshop on RTL Design using Verilog and Sky130 nm Technology.

## Tools used:

- Yosys is used to synthesize the verilog file and provide a netlist file.<br>
- iVerilog is used to simulate the verilog code with the corresponding testbench. <br>
- SKY130 Standard Cell Library was used to infer the gates level netlist from the verilog modules. <br>
- GTKWave is used to view the simulation and synthesis waveform. <br>

# 2. Day 1 - Introduction to Verilog RTL Design and Synthesis
## 2.1 SKY130RTL D1SK1 - Introduction to open-source simulator iverilog
### 2.1.1 SKY130RTL D1SK1 L1 Introduction iverilog design and test bench
<b> Simulator: </b> Simulator is a tool used to check whether the design complies with the desired specs. It does that by simulating the code. <br>
<br>
<b> Design: </b> It is the actual verilog code or set of verilog codes which has the intended functionality to meet with the required functionality/speciifications. <br>
<br>
<b> TestBench: </b> It is the setup to apply stimulus to the design to check its functionality. It doesn't contain any input/output ports. <br>
<br>
Simulator is constantly watching for any changes in the inputs mentioned in the sensitivity list. Upon the occurence of a change, it (re)evaluates the output signal.<br>
<br>
<p align = "center">
<img src="https://user-images.githubusercontent.com/62461290/183845210-c3b9712f-c56f-4d62-98d4-34d22ad78f10.png"> <br>
General Simulation Flow
</p>
<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/62461290/183845405-c8a1de5c-f949-4962-9952-6bf8e68c164f.png"> <br>
iVerilog Based Simulation Flow
</p>
 ### Why different flavours of gates?
The .lib file is a collection of logical modules. Any digital design can be implemented with the cells present in the stand cell library file. It includes logic gates like AND, OR, NOT, NAND, D_FFs, ....... etc. Also, it includes different flavours of the same gates such as 2-ip AND gate, 3-ip AND gate, 4-ip AND gate etc with different variations in speed, power and area. Yosys is the synthesizer used in this course. 

Combinational delay in logic patth determines the maximum speed of operation of digital logic circuit. So we need cells that work fast to decrease the Tclk. Basically, the faster cells have wider mosfets to increase their current driving capacities. 
<p align="center">
  <img width=""1000 height="200" src="/Images/Pic6.png">
</p><br>
But faster cells have wider mosfets, hence they 

- require more area (due to wider mosfets) and power (due to larger currents)
- May cause hold time violations
# 2. Timing Libraries, Hierarchical and Flat Synthesis
## 2.1 Introduction to Timing Libraries
When we look into any library, three important factrors are 
 - Process: Signifies some variation due to fabrication
 - Voltage: Voltage of operation
 - Temperature: Ideal temperature of Silicon


Keyword cell is used to define the keyword. As discussed earlier, there are different flavours of the same gate with varying area, power and delays. As an example, 2-ip AND gate is shown. Since 2-ip AND gate has 2 inputs, there are 4 possible input combinations. Power consumption of all the possible input combinations is mentioned in the `.lib` file. <br><br>

## 2.2 Hierarchical Synthesis and Flat Synthesis
When we perform hierarchical synthesis using the following commands,
```
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
write_verilog -noattr multiple_modules_synth.v
```
We get the following schematic. 
<p align="center">
  <img src="/Images/Pic13.png">
</p><br>


It can be clearly seen from waveform when select is <I> 0 </I> y is following <I> i0 </I> and when select is <I> 1 </I> y is following <I> i1 </I> <br>

### 2.2.3 SKY130RTL D1SK2 L3 Lab 2 Introduction to iVerilog GTKWave part2
```
Design File of 2:1 MUX

module good_mux (input i0 , input i1 , input sel , output reg y);
always @ (*)
begin
	if(sel)
		y <= i1;
	else 
		y <= i0;
end
endmodule
```

```
Testbench of 2:1 MUX

`timescale 1ns / 1ps
module tb_good_mux;
	reg i0,i1,sel; // Inputs
	wire y;  // Outputs
	good_mux uut (.sel(sel),.i0(i0),.i1(i1),.y(y)); // Instantiate the Unit Under Test (UUT)
	initial begin
	$dumpfile("tb_good_mux.vcd");
	$dumpvars(0,tb_good_mux);
	// Initialize Inputs
	sel = 0;
	i0 = 0;
	i1 = 0;
	#300 $finish;
	end
always #75 sel = ~sel;
always #10 i0 = ~i0;
always #55 i1 = ~i1;
endmodule
```
<br>
uut(unit under test) : It is the normal convention to name the top level module called in testbench as an uut. <br>

## 2.3 SKY130RTL D1SK3 - Introduction to Yosys and Logic Synthesis
### 2.3.1 SKY130RTL D1SK3 L1 Introduction to Yosys

- Synthesizer is a tool used for converting the RTL to Netlist. <br>
- Yosys is the synthesizer used in this course.

<p align="center">
<img src="https://user-images.githubusercontent.com/62461290/183900424-3847b18b-362f-403c-a932-94ae04f9d846.png"> <br>
Yosys Synthesis Setup
</p>

The same testbench that is used for the simulation can be used for the synthesized netlist as well. The output waveform of both Synthesis and Simulation have to match. <br>
<p align="center">
<img src="https://user-images.githubusercontent.com/62461290/183900461-350aa07f-ed24-41fc-8478-4ef49b2b8d73.png"> <br>
Verification of Synthesized Netlist
</p>

### 2.3.2 SKY130RTL D1SK3 L2 Introduction to logic synthesis part1
<b> Synthesis: </b> <br>
- The RTL design is converted into gates and the connections are made between gates. <br>
- This is given out as a file called netlist. <br>

<p align="center">
<img src="https://user-images.githubusercontent.com/62461290/183910992-4910d098-f175-484f-8dcc-20a989d41967.png"> <br>
</p>

<b> .lib </b>
- It contains all different kind of logic modules. like AND, OR, NOR etc.<br>
- It contains different variants of the same gate as well. like 2i/p, 3i/p, 4i/p, slow, fast, medium gates etc.<br>

There are different kind of gates avaiable to take in account the performance parameters like Delay, Area, Power into consideration. <br>
- If we choose speed we trade off area and power likewise if we choose area we trade off delay. Hence we have to choose them either based on the design constrains or find a sweet spot between all of them.

### 2.3.3 SKY130RTL D1SK3 L3 Introduction to logic synthesis part2

- Load in a digital logic circuit is a capacitor. <br>
- Fater the charging and discharging of capacitance the lesser is the delay. <br>
- To charge/Discharge the capacitor fast, we need transistors capable of sourcing more current. <br>
- Wider transistors -> low delay -> More Power and Area. <br>
- Narrow transitor -> More delay -> Less Area and Power. <br>

<b> Selection of Cells </b> <br>
- Need to guide the synthesizer to select the flavour of cells that is optimum for the implementation of logic circuits. <br>
- More use of fast cells can be bad interms of power and area. <br>
- More use of slow cells can lead to a sluggish circuit. <br>
- The guidence offered to the synthesizer is called constraints <br>

## 2.4 SKY130RTL D1SK4 - Labs Using Yosys and SKY130 PDKs
### 2.4.1 SKY130RTL D1SK4 L1 lab3 Yosys 1 good mux
Run the Following command in the terminal path where the respective files are saved.

```
$ yosys
$ read_liberty -lib /home/nandu/ASIC/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
$ read_verilog good_mux.v
$ synth -top good_mux
$ abc -liberty /home/nandu/ASIC/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
$ show
$ write_verilog -noattr good_mux_netlist.v
```

![Screenshot 2022-08-10 185824](https://user-images.githubusercontent.com/62461290/183915651-27b843a9-a4d4-465e-a367-021ea778e72e.png)
![Screenshot 2022-08-10 185805](https://user-images.githubusercontent.com/62461290/183915678-d039ba7e-ed50-457b-a8d1-c55e04b5ea6e.png)
![Screenshot 2022-08-10 185748](https://user-images.githubusercontent.com/62461290/183915719-bfeef00a-902f-4399-b3ed-4c6eb7789deb.png)
![Screenshot 2022-08-10 185716](https://user-images.githubusercontent.com/62461290/183915736-9062716e-656c-482b-aba0-3e9850e61b86.png)
![Screenshot 2022-08-10 185843](https://user-images.githubusercontent.com/62461290/183915748-6bcce7b9-74ff-4091-87f3-e613a021a76e.png)
![Screenshot 2022-08-10 190142](https://user-images.githubusercontent.com/62461290/183915783-6c390ea5-f1fd-4972-b1f2-84033ebc1642.png)

<p align="center">
<img src="https://user-images.githubusercontent.com/62461290/183915828-b6df3261-9923-4903-8a28-a7502b58988d.png"> <br>
Gate level model Generated
</p>

```
Netlist File Generated

/* Generated by Yosys 0.20+1 (git sha1 60a787fa500, clang  -fPIC -Os) */
module good_mux(i0, i1, sel, y);
  wire _0_;
  wire _1_;
  wire _2_;
  wire _3_;
  input i0;
  wire i0;
  input i1;
  wire i1;
  input sel;
  wire sel;
  output y;
  wire y;
  sky130_fd_sc_hd__mux2_1 _4_ ( .A0(_0_), .A1(_1_), .S(_2_), .X(_3_)  );
  assign _0_ = i0;
  assign _1_ = i1;
  assign _2_ = sel;
  assign y = _3_;
endmodule
```


Whereas, flattened netlist can be generated using the keyword `flatten`. The commands are as follows:
```
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog multiple_modules.v
synth -top multiple_modules
abc -liberty ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
flatten
show
write_verilog -noattr multiple_modules_synth.v
```
We get the following schematic. 
<p align="center">
  <img src="/Images/Pic14.png">
</p><br>

## We can perform module level synthesis as well. But why do this?
There are two circumstances when we do this 
 - Module level synthesis is preferred when we have multiple instances of the same module. For example, if a design uses n multipliers where n is a large number, then, we synthesise the multiplier once and use it multiple times.
 - This approach is used for divide and conquer. If the design is too massive for the synthesis tool, we synthesis mudule by module and stitch them to get the entire design. 

## 2.3 Various Flip Flop coding Styles and Optimizations
In a combinational circuit, when the inputs are altered, the output changes after the circuit's propagation delay. If several pathways with differing propagation delays are used during data propagation, there may be a probability of an output glitch. Because more glitches arise when there are more combinational circuits in the design, the output becomes unstable. We are opting for flops to store the data from the communication lines in order to address this issue. When a flop is utilised, the output of the combinational circuit is stored in it and transmitted only at the positive or negative edge of the clock so that the subsequent combinational circuit receives a glitch-free input, stabilising the output. The set and reset control pins of a flop are used as initialization signals because without them, the following combinational circuit would get a trash value. Both synchronous and asynchronous control pins are possible.

### D Flip Flop with Asynchronous Reset
```
module dff_asyncres ( input clk ,  input async_reset , input d , output reg q );
always @ (posedge clk , posedge async_reset)
begin
	if(async_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
<p align="center">
  <img src="/Images/Pic15.png">
</p><br>

<p align="center">
  <img src="/Images/Pic16.png">
</p><br>

### D Flip Flop with Asynchronous Set
```
module dff_async_set ( input clk ,  input async_set , input d , output reg q );
always @ (posedge clk , posedge async_set)
begin
	if(async_set)
		q <= 1'b1;
	else	
		q <= d;
end
endmodule
```
<p align="center">
  <img src="/Images/Pic17.png">
</p><br>

<p align="center">
  <img src="/Images/Pic18.png">
</p><br>

### D Flip Flop with Synchronous Reset
```
module dff_syncres ( input clk , input async_reset , input sync_reset , input d , output reg q );
always @ (posedge clk )
begin
	if (sync_reset)
		q <= 1'b0;
	else	
		q <= d;
end
endmodule
```
<p align="center">
  <img src="/Images/Pic19.png">
</p><br>

<p align="center">
  <img src="/Images/Pic20.png">
</p><br>


## 2.4 Interesting Optimizations
In this lab, we consider the implementation of multipliers.
```
module mul2 (input [2:0] a, output [3:0] y);
	assign y = a * 2;
endmodule
```
Here, yosys implements this design just by left shift operator.
<p align="center">
  <img src="/Images/Pic21.png">
</p><br>

Similarly, 
```
module mult8 (input [2:0] a , output [5:0] y);
	assign y = a * 9;
endmodule
```
Here, this multiplier is implemented as `a*8 + a*1`. Since a is 3-bit, it `a*9 = aa`
<p align="center">
  <img src="/Images/Pic22.png">
</p><br>

# 3. Combinational and Sequential Optimization
## 3.1 Introduction to Optimizations
### Combinational Logic Optimizations
Combinational logic optimizations helps in squeezing the logic to get the most optimized design. Also, optimized logic will be power and area efficient.
Techniques used for combinational logic optimization are 
 - Constant Propogation - direct optimization technique
 - Boolean Logic Optimization - KMap, Quinn Muclusky, etc

### Sequential Logic Optimizations
Sequential Logic Optimization techniques include
 - Basic - Sequential Constant Propogation
 - Advanced
    - State Optimization
    - Retiming
    - Sequential Logic Cloning (Floorplan aware synthesis)
   
## 3.2 Combinational Logic Optimizations
The command used to perform logic optimization of combinational logic is `opt_clean -purge`. Here we consider the example opt_check.v,opt_check2.v, opt_check3.v, opt_check4.v and multiple_module_opt.v.

### Example: opt_check.v
```
module opt_check (input a , input b , output y);
	assign y = a?b:0;
endmodule
```
The commands to run optimizations are
```
read_liberty -lib ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
read_verilog opt_check.v
synth -top opt_check
opt_clean -purge
abc -liberty ../my_lib/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
show
write_verilog -noattr opt_check_synth.v
```
<p align="center">
  <img src="/Images/Pic23.png">
</p><br>

### Example: opt_check2.v
```
module opt_check2 (input a , input b , output y);
	assign y = a?1:b;
endmodule
```
<p align="center">
  <img src="/Images/Pic24.png">
</p><br>

### Example: opt_check3.v
```
module opt_check3 (input a , input b, input c , output y);
	assign y = a?(c?b:0):0;
endmodule
```
<p align="center">
  <img src="/Images/Pic25.png">
</p><br>


### Example: opt_check4.v
```
module opt_check4 (input a , input b , input c , output y);
 assign y = a?(b?(a & c ):c):(!c);
 endmodule
```
<p align="center">
  <img src="/Images/Pic26.png">
</p><br>

## 3.3 Sequential Logic Optimizations
### Example-1
```
module dff_const1(input clk, input reset, output reg q);
	always @(posedge clk, posedge reset)
	begin
		if(reset)
			q <= 1'b0;
		else
			q <= 1'b1;
	end
endmodule
```
<p align="center">
  <img src="/Images/Pic27.png">
</p><br>
<p align="center">
  <img src="/Images/Pic28.png">
</p><br>

### Example-2
```
module dff_const2(input clk, input reset, output reg q);
always @(posedge clk, posedge reset)
begin
	if(reset)
		q <= 1'b1;
	else
		q <= 1'b1;
end

endmodule
```
Here, since the output is always 1, just a buffer is sufficient. No need of flipflop.
<p align="center">
  <img src="/Images/Pic29.png">
</p><br>


### Example-3
```
module dff_const3(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
<p align="center">
  <img src="/Images/Pic30.png">
</p><br>
<p align="center">
  <img src="/Images/Pic31.png">
</p><br>

### Example-4
```
module dff_const4(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b1;
		q1 <= 1'b1;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
Here, since the output is always 1, just a buffer is sufficient. No need of flipflop.
<p align="center">
  <img src="/Images/Pic32.png">
</p><br>
<p align="center">
  <img src="/Images/Pic33.png">
</p><br>

### Example-5
```
module dff_const5(input clk, input reset, output reg q);
reg q1;

always @(posedge clk, posedge reset)
begin
	if(reset)
	begin
		q <= 1'b0;
		q1 <= 1'b0;
	end
	else
	begin
		q1 <= 1'b1;
		q <= q1;
	end
end

endmodule
```
Here, no optimizations are possible
<p align="center">
  <img src="/Images/Pic34.png">
</p><br>
<p align="center">
  <img src="/Images/Pic35.png">
</p><br>

## 3.4 Sequential Optimization for unused outputs
### Example 1
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = count[0];

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
Here the output of the module is just sensing the output q as count[0] Basically q toggles on every clock cycle. count[1] and count[2] have no functionality. So one d_ff and one inverter will realize the circuit.

<p align="center">
  <img src="/Images/Pic36.png">
</p><br>

### Example 2
```
module counter_opt (input clk , input reset , output q);
reg [2:0] count;
assign q = (count[2:0] == 3'b100);

always @(posedge clk ,posedge reset)
begin
	if(reset)
		count <= 3'b000;
	else
		count <= count + 1;
end

endmodule
```
Here, all the three flip flops are inferred.

<p align="center">
  <img src="/Images/Pic37.png">
</p><br>

We can conclude that all the logicthat does not have imact in determining the primary output of the design, all of the those logics will be eliminated.

# 4. GLS, Blocking vs Nonblocking and Synthesis-Simulation Mismatch
## 4.1 GLS Concepts And Flow 
### What is GLS?
GLS stands for gate level simulation. When we write the RTL code, we test it by giving it some stimulus through the testbench and check it for the desired specifications. Similarly, we run the netlist as the design under test (dut) with the same testbench. 
### Why GLS?
Gate level simulation is done to verify the logical correctness of the design after synthesis. Also, it ensures the timing of the design. 

<p align="center">
  <img src="/Images/Pic38.png">
</p><br>
## 4.2 Synthesis Simulation Mismatch
The possible reasons for Synthesis Simulation Mismatches are 
 - Missing Sensitivity List
 - Blocking and Nonblocking Assignments
 - Non-standard Verilog Coding Practices

## 4.3 Missing Sensitivity List
The simulator works based on the activity, i.e., output will change only when input changes. Consider an example of a mux below.
```
module mux (input i0, input i1, input sel, output reg y);
	always@(sel)
		begin
			if(sel)
				y = i1;
			else
				y = i0;
		end
endmodule
```
Here, we did a major blunder. We have included only `sel` in the sensitivity list. Actually, we should have included `sel`, `i0` and `i1`. So, we get the following wrong waveform. 

<p align="center">
  <img src="/Images/Pic39.png">
</p><br>

Alternatively, we can write this code, which works properly. 
```
module mux (input i0, input i1, input sel, output reg y);
	always@()
		begin
			if(sel)
				y = i1;
			else
				y = i0;
		end
endmodule
```
<p align="center">
  <img src="/Images/Pic40.png">
</p><br>


## 4.4 Blocking and Nonblocking Statements in Verilog
### What is blocking and non-blocking statements in verilog?
Inside always block, `=` represents blocking assignment and `<=` represents non-blocking assignment. Blocking assignment follows sequential execution like C program. Whereas, non-blocking statement follows parallel evaluation. Basically, in non-blocking assignment, RHS will be evaluated first, then the LHS is evaluated. 
<br>
Consider the following example. Here the output is depending on the past value of x which is dependednt on a and b and it appears like a flop.
```
module blocking_caveat (input a , input b , input  c, output reg d); 
	reg x;
	always @ (*)
		begin
		d = x & c;
		x = a | b;
	end
endmodule
```

Conder another example, where we are trying to build a shift register.
Here, due to improper use of assignment statements, instead of shift register, a single flop is inferred.
```
module code(input clk, input reset, input d, output reg q);
	reg q0;
	always@(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q0 = 1'b0;
			q = 1'b0;
		end
		else
		begin
			q0 = d
			q = q0;
		end
	end
endmodule
```
<br>
Here, proper shift register.

```
module code(input clk, input reset, input d, output reg q);
	reg q0;
	always@(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q0 = 1'b0;
			q = 1'b0;
		end
		else
		begin
			q = q0;
			q0 = d
		end
	end
endmodule
```

<br>
Also, the same design can be efficiently implemented using nonblocking statements.


```
module code(input clk, input reset, input d, output reg q);
	reg q0;
	always@(posedge clk, posedge reset)
	begin
		if(reset)
		begin
			q0 <= 1'b0;
			q <= 1'b0;
		end
		else
		begin
			q0 <= d
			q <= q0;
		end
	end
endmodule
```

So, we can conclude that nonblocking statements are a better option to design sequential circuits.

# 5. If, case, for and for generate
## 5.1 If and Case Construct
### If statement
If is mainly used to create conditional logic. Syntax of if statement is shown below.
```
if (<condition 1>)
	begin
	-----------
	-----------
	end
else if (<condition 2>)
	begin
	-----------
	-----------
	end
.
.
.
else 
	begin
	----------
	----------
	end
```

This creates a priority logic, i.e., `condition 1` has the highest priority followed by `condition 2` and so on. This synthesis a cascaded mux in the design. 
<p align="center">
  <img src="/Images/Pic41.png">
</p><br>

### Dangers of using if:
The main danger of using if statements is inferred latches in the design. This may occur if we write incompletely specified if statements. However, sometimes it is fine to write imcomplete if statements as in the case of counter.

```
always@(posedge clk)
begin
	if(reset)
		count <= 3'b000;
	else if(enable)
		count <= count+1;
end
```
Consider an example of incompletely specified if statement
```
module incomp_if (input i0 , input i1 , input i2 , output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
end
endmodule
```
Since there is no else statement, a D Latch is inferred.
<p align="center">
  <img src="/Images/Pic42.png">
</p><br>

Consider another example,
```
module incomp_if2 (input i0 , input i1 , input i2 , input i3, output reg y);
always @ (*)
begin
	if(i0)
		y <= i1;
	else if (i2)
		y <= i3;

end
endmodule
```
Since there is no else statement, a D Latch is inferred.
<p align="center">
  <img src="/Images/Pic43.png">
</p><br>


### Case Statement

In `case` constructs, unlike if statements, there is no priority given to any conditions. All conditions are treated equally. The syntax of `case` construct is shown below.
```
case(statement)
  case1: begin
       --------
	 --------
	 end
 case2: begin
	     --------
	 --------
	 end
 default:
 endcase
 ```
 
 ### Caveats of `case` constructs:
  - Incomplete case constructs inferres a latch. So, always try to have a default statement in case.
  - Partial assignment inside the case might also infer a latch. So assign all the outpits in all the segments of the case.
  - Never have overlapping cases. Unlike if, there is no priority in case. So, all the overlapping case statements gets executed.
  
Consider an example of incompletely specied case statement,
```
module incomp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
	always @ (*)
	begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
	endcase
	end
endmodule
```
Here also, a latch is inferred for case `2'b10` and `2'b11`.
<p align="center">
  <img src="/Images/Pic44.png">
</p><br>

The previous error can be rectified just by adding a default case,
```
module comp_case (input i0 , input i1 , input i2 , input [1:0] sel, output reg y);
always @ (*)
begin
	case(sel)
		2'b00 : y = i0;
		2'b01 : y = i1;
		default : y = i2;
	endcase
end
endmodule
```
<p align="center">
  <img src="/Images/Pic45.png">
</p><br>

Consider an example of partial case assignment, where a latch is inferred
```
module partial_case_assign (input i0 , input i1 , input i2 , input [1:0] sel, output reg y , output reg x);
always @ (*)
begin
	case(sel)
		2'b00 : begin
			y = i0;
			x = i2;
			end
		2'b01 : y = i1;
		default : begin
	         	  x = i1;
			  y = i2;
		 	 end
	endcase
end
endmodule
```
<p align="center">
  <img src="/Images/Pic46.png">
</p><br>

## 5.2 Looping Constructs in Verilog
Two possible looping constructs are available in verilog
 - for loop: Used inside the always block, to evaluate multiple instructions
 - generate loop: Used outsidde always block to for instaciating hardware
 
### Example:
To generate 256:1 mux, we can use for loop

```
integer i;
always@(*)
	for(i=0; i<256; i = i+1)
		if(i == sel)
			y = inp[i];
```

Consider an example of generating a mux using `for` loop,

```
module mux_generate (input i0 , input i1, input i2 , input i3 , input [1:0] sel  , output reg y);
wire [3:0] i_int;
assign i_int = {i3,i2,i1,i0};
integer k;
always @ (*)
begin
for(k = 0; k < 4; k=k+1) begin
	if(k == sel)
		y = i_int[k];
end
end
endmodule
```
<p align="center">
  <img src="/Images/Pic47.png">
</p><br>

Whereas, consider an example of Ripple carry adder, designed using full adders. Here, we can use generate block.

```
module rca (input [7:0] num1 , input [7:0] num2 , output [8:0] sum);
wire [7:0] int_sum;
wire [7:0]int_co;

genvar i;
generate
	for (i = 1 ; i < 8; i=i+1) begin
		fa u_fa_1 (.a(num1[i]),.b(num2[i]),.c(int_co[i-1]),.co(int_co[i]),.sum(int_sum[i]));
	end

endgenerate
fa u_fa_0 (.a(num1[0]),.b(num2[0]),.c(1'b0),.co(int_co[0]),.sum(int_sum[0]));


assign sum[7:0] = int_sum;
assign sum[8] = int_co[7];
endmodule
```
<p align="center">
  <img src="/Images/Pic48.png">
</p><br>

# 6. Acknowledgments


- Kunal Ghosh, Director, VSD Corp. Pvt. Ltd.
- Madhav Rao, Associate Professor, IIIT Bangalore
